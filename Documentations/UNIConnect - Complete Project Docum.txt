UNIConnect - Complete Project Documentation (Continued Part 6)
12. Edge Cases & Validations
┌─────────────────────────────────────────────────────────────┐
│          EDGE CASES & ERROR HANDLING                         │
└─────────────────────────────────────────────────────────────┘

══════════════════════════════════════════════════════════════
USER PROFILE EDGE CASES
══════════════════════════════════════════════════════════════

CASE 1: User Without Consent Tries to Access Features
┌────────────────────────────────────────────────────────────┐
│ Scenario:                                                   │
│ User logs in but hasn't given consent yet                   │
│                                                             │
│ Prevention:                                                 │
│ Dashboard.js:                                              │
│ const needsConsent = !currentUser?.consent_given;          │
│                                                             │
│ if (needsConsent) {                                        │
│   // Show alert banner                                     │
│   <Alert variant="destructive">                            │
│     Consent Required: Please complete the data protection  │
│     consent process to access platform features.           │
│     <Link to="/profile">Complete Now →</Link>              │
│   </Alert>                                                  │
│ }                                                           │
│                                                             │
│ Delegates.js:                                              │
│ useEffect(() => {                                          │
│   if (!currentUser?.consent_given) {                       │
│     navigate('/profile');                                  │
│     return;                                                 │
│   }                                                         │
│   loadDelegates();                                         │
│ }, [currentUser]);                                         │
│                                                             │
│ Result:                                                     │
│ • User cannot browse delegates                              │
│ • User cannot send meeting requests                         │
│ • User redirected to profile to give consent                │
└────────────────────────────────────────────────────────────┘

CASE 2: Incomplete Profile Trying to Network
┌────────────────────────────────────────────────────────────┐
│ Scenario:                                                   │
│ User gave consent but didn't complete profile               │
│                                                             │
│ Prevention:                                                 │
│ Delegates.js:                                              │
│ const filteredDelegates = allDelegates.filter(delegate =>  │
│   delegate.profile_completed &&                            │
│   delegate.consent_given &&                                │
│   !delegate.is_profile_hidden &&                           │
│   delegate.id !== currentUser?.id                          │
│ );                                                          │
│                                                             │
│ If user's profile incomplete:                               │
│ <Alert>                                                     │
│   Complete your profile to appear in the directory and     │
│   connect with other delegates.                            │
│   <Link to="/profile">Complete Profile →</Link>            │
│ </Alert>                                                    │
│                                                             │
│ Result:                                                     │
│ • User can see other delegates                              │
│ • User doesn't appear in directory for others               │
│ • Cannot send meeting requests until profile complete       │
└────────────────────────────────────────────────────────────┘

CASE 3: Editing Profile with Validation Errors
┌────────────────────────────────────────────────────────────┐
│ Scenario:                                                   │
│ User tries to save profile with missing required fields     │
│                                                             │
│ Validation:                                                 │
│ const validateProfile = () => {                            │
│   const errors = [];                                       │
│                                                             │
│   if (!formData.representation_type) {                     │
│     errors.push("Representation type is required");        │
│   }                                                         │
│   if (!formData.country) {                                 │
│     errors.push("Country is required");                    │
│   }                                                         │
│   if (!formData.job_title) {                               │
│     errors.push("Job title is required");                  │
│   }                                                         │
│   if (!formData.organization) {                            │
│     errors.push("Organization is required");               │
│   }                                                         │
│   if (!formData.industry_sector) {                         │
│     errors.push("Industry sector is required");            │
│   }                                                         │
│   if (!formData.biography || formData.biography.length < 50) {│
│     errors.push("Biography must be at least 50 characters");│
│   }                                                         │
│   if (!formData.topical_interests?.length) {               │
│     errors.push("At least one topical interest required"); │
│   }                                                         │
│   if (!formData.geographical_interests?.length) {          │
│     errors.push("At least one geographical interest required");│
│   }                                                         │
│                                                             │
│   return errors;                                           │
│ };                                                          │
│                                                             │
│ const handleSave = async () => {                           │
│   const errors = validateProfile();                        │
│   if (errors.length > 0) {                                 │
│     setValidationErrors(errors);                           │
│     return;                                                 │
│   }                                                         │
│   // Proceed with save                                     │
│ };                                                          │
│                                                             │
│ Display:                                                    │
│ {validationErrors.length > 0 && (                          │
│   <Alert variant="destructive">                            │
│     <AlertCircle className="h-4 w-4" />                    │
│     <AlertDescription>                                     │
│       Please fix the following errors:                     │
│       <ul className="list-disc pl-4 mt-2">                 │
│         {validationErrors.map((error, i) => (              │
│           <li key={i}>{error}</li>                         │
│         ))}                                                 │
│       </ul>                                                 │
│     </AlertDescription>                                     │
│   </Alert>                                                  │
│ )}                                                          │
│                                                             │
│ Result:                                                     │
│ • Form doesn't submit                                       │
│ • Clear error messages shown                                │
│ • User can fix and retry                                    │
└────────────────────────────────────────────────────────────┘

══════════════════════════════════════════════════════════════
MEETING REQUEST EDGE CASES
══════════════════════════════════════════════════════════════

CASE 4: Requesting Meeting with Self
┌────────────────────────────────────────────────────────────┐
│ Scenario:                                                   │
│ User accidentally selects themselves as recipient           │
│                                                             │
│ Prevention:                                                 │
│ RequestMeetingDialog.jsx:                                  │
│                                                             │
│ // Filter out current user from delegate list               │
│ const availableDelegates = allDelegates.filter(            │
│   d => d.id !== currentUser.id &&                          │
│        d.profile_completed &&                              │
│        d.consent_given                                     │
│ );                                                          │
│                                                             │
│ // Validation before submit                                │
│ const handleSubmit = () => {                               │
│   if (selectedRecipients.includes(currentUser.id)) {       │
│     setError("You cannot send a meeting request to yourself");│
│     return;                                                 │
│   }                                                         │
│   // Proceed                                               │
│ };                                                          │
│                                                             │
│ Result:                                                     │
│ • Current user not shown in recipient list                  │
│ • Validation prevents self-requests                         │
└────────────────────────────────────────────────────────────┘

CASE 5: Sending Multiple Requests to Same Person
┌────────────────────────────────────────────────────────────┐
│ Scenario:                                                   │
│ User tries to send multiple meeting requests to same person │
│                                                             │
│ Handling:                                                   │
│ • System ALLOWS multiple requests (by design)               │
│ • Each request is separate with unique meeting code         │
│ • Recipient can accept/decline each independently           │
│                                                             │
│ Rationale:                                                  │
│ • Different topics may require separate meetings            │
│ • Follow-up meetings after initial connection               │
│ • Flexibility for users                                     │
│                                                             │
│ Optional Enhancement (not implemented):                     │
│ const hasExistingRequest = existingRequests.some(          │
│   r => r.recipient_ids.includes(recipientId) &&            │
│       r.status === 'pending'                               │
│ );                                                          │
│                                                             │
│ if (hasExistingRequest) {                                  │
│   <Alert>                                                   │
│     You already have a pending request with this person.   │
│     Are you sure you want to send another?                 │
│   </Alert>                                                  │
│ }                                                           │
└────────────────────────────────────────────────────────────┘

CASE 6: Accepting Already Accepted Request
┌────────────────────────────────────────────────────────────┐
│ Scenario:                                                   │
│ Two recipients try to accept same request simultaneously    │
│                                                             │
│ Prevention:                                                 │
│ Meetings.js:                                               │
│                                                             │
│ const handleRequestResponse = async (requestId, response) => {│
│   // Fetch fresh data                                      │
│   const currentRequest = await MeetingRequest.get(requestId);│
│                                                             │
│   // Check current status                                  │
│   if (currentRequest.status !== 'pending') {               │
│     setError(`This request has already been ${             │
│       currentRequest.status                                │
│     }`);                                                    │
│     await loadData(); // Refresh UI                        │
│     return;                                                 │
│   }                                                         │
│                                                             │
│   // Proceed with update                                   │
│   await MeetingRequest.update(requestId, {                 │
│     status: response                                       │
│   });                                                       │
│ };                                                          │
│                                                             │
│ Result:                                                     │
│ • Only first response is saved                              │
│ • Second attempt shows error message                        │
│ • UI refreshes to show current state                        │
└────────────────────────────────────────────────────────────┘

CASE 7: Modifying Meeting After Venue Booked
┌────────────────────────────────────────────────────────────┐
│ Scenario:                                                   │
│ User modifies meeting duration after venue already booked   │
│                                                             │
│ Handling:                                                   │
│ Dashboard.js / Meetings.js:                                │
│                                                             │
│ const handleSaveModification = async () => {               │
│   const originalDuration = editingMeeting.proposed_duration;│
│   const newDuration = modifyForm.proposed_duration;        │
│   const durationChanged = originalDuration !== newDuration;│
│                                                             │
│   let venueCleared = false;                                │
│   let associatedBooking = null;                            │
│                                                             │
│   if (durationChanged) {                                   │
│     // Find associated booking                             │
│     associatedBooking = bookings.find(booking =>           │
│       booking.meeting_request_id === editingMeeting.id &&  │
│       booking.status === 'active'                          │
│     );                                                      │
│   }                                                         │
│                                                             │
│   // Update meeting, clear venue if duration changed       │
│   await MeetingRequest.update(editingMeeting.id, {         │
│     proposed_topic: modifyForm.proposed_topic,             │
│     proposed_duration: newDuration,                        │
│     personal_message: modifyForm.personal_message,         │
│     ...(durationChanged && { venue_booking_id: null })     │
│   });                                                       │
│                                                             │
│   // Cancel booking if duration changed                    │
│   if (associatedBooking) {                                 │
│     await VenueBooking.update(associatedBooking.id, {      │
│       status: 'cancelled'                                  │
│     });                                                     │
│     venueCleared = true;                                   │
│   }                                                         │
│                                                             │
│   // Notify participants                                   │
│   await Notification.create({                              │
│     user_id: otherParticipantId,                           │
│     type: 'meeting_updated',                               │
│     title: 'Meeting Details Updated',                      │
│     body: `${currentUser.full_name} has updated the details`│
│           + ` for your meeting "${modifyForm.proposed_topic}".`│
│           + (venueCleared ? ' The venue has been cleared and'│
│           + ' needs to be re-booked.' : ''),               │
│     link: "/meetings"                                      │
│   });                                                       │
│ };                                                          │
│                                                             │
│ User sees warning:                                         │
│ <Alert>                                                     │
│   ⚠️ Changing the duration will cancel any existing venue  │
│   booking for this meeting.                                │
│ </Alert>                                                    │
│                                                             │
│ Result:                                                     │
│ • Booking cancelled automatically                           │
│ • Participants notified                                     │
│ • Need to rebook venue with new duration                    │
└────────────────────────────────────────────────────────────┘

CASE 8: Cancelling Meeting with Active Booking
┌────────────────────────────────────────────────────────────┐
│ Scenario:                                                   │
│ User cancels meeting that has venue booking                 │
│                                                             │
│ Handling:                                                   │
│ Meetings.js:                                               │
│                                                             │
│ const handleCancelMeeting = async (meeting) => {           │
│   // Update meeting status                                 │
│   await MeetingRequest.update(meeting.id, {                │
│     status: 'cancelled'                                    │
│   });                                                       │
│                                                             │
│   // Find and cancel associated booking                    │
│   const associatedBooking = bookings.find(booking =>       │
│     booking.meeting_request_id === meeting.id &&           │
│     booking.status === 'active'                            │
│   );                                                        │
│                                                             │
│   if (associatedBooking) {                                 │
│     await VenueBooking.update(associatedBooking.id, {      │
│       status: 'cancelled'                                  │
│     });                                                     │
│   }                                                         │
│                                                             │
│   // Notify all participants                               │
│   const participants = [                                   │
│     meeting.requester_id,                                  │
│     ...(meeting.recipient_ids || [])                       │
│   ].filter(id => id !== currentUser.id);                   │
│                                                             │
│   for (const participantId of participants) {              │
│     await Notification.create({                            │
│       user_id: participantId,                              │
│       type: 'request_status_update',                       │
│       title: 'Meeting Cancelled',                          │
│       body: `${currentUser.full_name} has cancelled your ` │
│             + `meeting "${meeting.proposed_topic}" `       │
│             + `(Code: ${meeting.meeting_code}).`,          │
│       link: "/meetings"                                    │
│     });                                                     │
│   }                                                         │
│ };                                                          │
│                                                             │
│ Confirmation Dialog:                                       │
│ ┌──────────────────────────────────────────────────────┐  │
│ │ Cancel Meeting?                                       │  │
│ │                                                        │  │
│ │ ⚠️ This action cannot be undone.                      │  │
│ │                                                        │  │
│ │ Meeting: U.S.-France Climate Cooperation              │  │
│ │ With: Maria Dubois                                    │  │
│ │ Code: A7K9M2N4                                        │  │
│ │                                                        │  │
│ │ {associatedBooking && (                               │  │
│ │   <Alert>                                             │  │
│ │     This will also cancel the venue booking for       │  │
│ │     Board Room on Jan 23 at 10:30 AM                  │  │
│ │   </Alert>                                            │  │
│ │ )}                                                     │  │
│ │                                                        │  │
│ │ All participants will be notified.                    │  │
│ │                                                        │  │
│ │ [Keep Meeting] [Cancel Meeting]                       │  │
│ └──────────────────────────────────────────────────────┘  │
│                                                             │
│ Result:                                                     │
│ • Meeting status changed to 'cancelled'                     │
│ • Venue booking cancelled                                   │
│ • Room becomes available again                              │
│ • All participants notified                                 │
│ • Meeting moves to "Request History" tab                    │
└────────────────────────────────────────────────────────────┘

══════════════════════════════════════════════════════════════
VENUE BOOKING EDGE CASES
══════════════════════════════════════════════════════════════

CASE 9: Double Booking Prevention
┌────────────────────────────────────────────────────────────┐
│ Scenario:                                                   │
│ Two users try to book same room for same time slot          │
│                                                             │
│ Prevention:                                                 │
│ BookingDialog.jsx:                                         │
│                                                             │
│ const isTimeSlotAvailable = (room, startTime, endTime) => {│
│   return !bookings.some(booking =>                         │
│     booking.room_id === room.id &&                         │
│     booking.status === 'active' &&                         │
│     (                                                       │
│       (new Date(startTime) >= new Date(booking.start_time) &&│
│        new Date(startTime) < new Date(booking.end_time)) ||│
│       (new Date(endTime) > new Date(booking.start_time) &&  │
│        new Date(endTime) <= new Date(booking.end_time)) || │
│       (new Date(startTime) <= new Date(booking.start_time) &&│
│        new Date(endTime) >= new Date(booking.end_time))    │
│     )                                                       │
│   );                                                        │
│ };                                                          │
│                                                             │
│ const handleBooking = async () => {                        │
│   // Check availability before booking                     │
│   if (!isTimeSlotAvailable(room, startTime, endTime)) {    │
│     setError("This time slot is no longer available. " +   │
│              "Please select a different time.");           │
│     await loadBookings(); // Refresh                       │
│     return;                                                 │
│   }                                                         │
│                                                             │
│   // Proceed with booking                                  │
│   await VenueBooking.create({...});                        │
│ };                                                          │
│                                                             │
│ UI Feedback:                                               │
│ • Time slots show as unavailable in real-time               │
│ • Error message if booking fails                            │
│ • Schedule automatically refreshes                          │
│                                                             │
│ Result:                                                     │
│ • Only first booking succeeds                               │
│ • Second attempt fails with clear message                   │
│ • User shown updated availability                           │
└────────────────────────────────────────────────────────────┘

CASE 10: Booking Inactive Room
┌────────────────────────────────────────────────────────────┐
│ Scenario:                                                   │
│ Admin deactivates room while user is booking it             │
│                                                             │
│ Prevention:                                                 │
│ BookingDialog.jsx:                                         │
│                                                             │
│ const handleBooking = async () => {                        │
│   // Fetch fresh room data                                 │
│   const currentRoom = await VenueRoom.get(room.id);        │
│                                                             │
│   // Check if still active                                 │
│   if (!currentRoom.is_active) {                            │
│     setError("This room is no longer available for booking.");│
│     closeDialog();                                         │
│     return;                                                 │
│   }                                                         │
│                                                             │
│   // Proceed with booking                                  │
│ };                                                          │
│                                                             │
│ Venues.js (room list):                                     │
│ • Only show active rooms in booking options                 │
│ • Filter: rooms.filter(r => r.is_active)                   │
│                                                             │
│ Result:                                                     │
│ • Inactive rooms not bookable                               │
│ • Clear error message if room becomes inactive              │
└────────────────────────────────────────────────────────────┘

CASE 11: Booking Room with Insufficient Capacity
┌────────────────────────────────────────────────────────────┐
│ Scenario:                                                   │
│ Multi-user meeting tries to book small room                 │
│                                                             │
│ Validation:                                                 │
│ BookingDialog.jsx:                                         │
│                                                             │
│ const participantCount = 1 + meeting.recipient_ids.length; │
│                                                             │
│ const roomCapacityWarning = room.capacity < participantCount;│
│                                                             │
│ {roomCapacityWarning && (                                  │
│   <Alert variant="warning">                                │
│     ⚠️ This room has capacity for {room.capacity} people,  │
│     but your meeting has {participantCount} participants.  │
│     Consider choosing a larger room.                       │
│   </Alert>                                                  │
│ )}                                                          │
│                                                             │
│ Handling:                                                   │
│ • System allows booking (user decision)                     │
│ • Shows warning to user                                     │
│ • Suggests larger rooms                                     │
│                                                             │
│ Optional (not implemented):                                 │
│ • Could prevent booking if capacity exceeded                │
│ • Could auto-filter rooms by participant count              │
└────────────────────────────────────────────────────────────┘

CASE 12: Overlapping Personal Meetings
┌────────────────────────────────────────────────────────────┐
│ Scenario:                                                   │
│ User books venue at time when they have another meeting     │
│                                                             │
│ Warning:                                                    │
│ BookingDialog.jsx:                                         │
│                                                             │
│ const hasConflict = myMeetings.some(meeting => {           │
│   const meetingBooking = bookings.find(                    │
│     b => b.meeting_request_id === meeting.id &&            │
│          b.status === 'active'                             │
│   );                                                        │
│   if (!meetingBooking) return false;                       │
│                                                             │
│   return (                                                  │
│     new Date(selectedTime) < new Date(meetingBooking.end_time) &&│
│     new Date(selectedEndTime) > new Date(meetingBooking.start_time)│
│   );                                                        │
│ });                                                         │
│                                                             │
│ {hasConflict && (                                          │
│   <Alert variant="destructive">                            │
│     ⚠️ You have another meeting scheduled during this time.│
│     Are you sure you want to book this slot?               │
│   </Alert>                                                  │
│ )}                                                          │
│                                                             │
│ Result:                                                     │
│ • User warned about conflict                                │
│ • Can proceed if intentional                                │
│ • Helps prevent scheduling mistakes                         │
└────────────────────────────────────────────────────────────┘

══════════════════════════════════════════════════════════════
CHAT & MESSAGING EDGE CASES
══════════════════════════════════════════════════════════════

CASE 13: Sending Message to Declined Meeting
┌────────────────────────────────────────────────────────────┐
│ Scenario:                                                   │
│ User tries to access chat for declined/cancelled meeting    │
│                                                             │
│ Prevention:                                                 │
│ Chat.js:                                                   │
│                                                             │
│ useEffect(() => {                                          │
│   const requestId = urlParams.get('request');              │
│   const meeting = await MeetingRequest.get(requestId);     │
│                                                             │
│   if (meeting.status !== 'accepted') {                     │
│     setError(                                              │
│       `Chat is only available for accepted meetings. ` +   │
│       `This meeting is currently ${meeting.status}.`       │
│     );                                                      │
│     return;                                                 │
│   }                                                         │
│                                                             │
│   loadMessages();                                          │
│ }, []);                                                     │
│                                                             │
│ UI Display:                                                │
│ <Alert variant="destructive">                              │
│   <AlertCircle className="h-4 w-4" />                      │
│   Chat is only available for accepted meetings.            │
│   This meeting is currently declined.                      │
│ </Alert>                                                    │
│                                                             │
│ Meetings.js:                                               │
│ • Chat button only shown for accepted meetings              │
│ • Button disabled for other statuses                        │
│                                                             │
│ Result:                                                     │
│ • No chat access for non-accepted meetings                  │
│ • Clear explanation shown to user                           │
└────────────────────────────────────────────────────────────┘

CASE 14: Empty Message Submission
┌────────────────────────────────────────────────────────────┐
│ Scenario:                                                   │
│ User tries to send empty or whitespace-only message         │
│                                                             │
│ Prevention:                                                 │
│ Chat.js:                                                   │
│                                                             │
│ const handleSendMessage = async () => {                    │
│   // Trim whitespace                                       │
│   const trimmedMessage = newMessage.trim();                │
│                                                             │
│   // Validate                                              │
│   if (!trimmedMessage) {                                   │
│     return; // Don't send                                  │
│   }                                                         │
│                                                             │
│   // Proceed                                               │
│   await ChatMessage.create({                               │
│     meeting_request_id: meetingRequestId,                  │
│     sender_id: currentUser.id,                             │
│     recipient_id: otherParticipant.id,                     │
│     message: trimmedMessage,                               │
│     read_status: false                                     │
│   });                                                       │
│                                                             │
│   setNewMessage(''); // Clear input                        │
│ };                                                          │
│                                                             │
│ Send button state:                                         │
│ <Button                                                     │
│   onClick={handleSendMessage}                              │
│   disabled={!newMessage.trim() || sending}                 │
│ >                                                           │
│   Send                                                      │
│ </Button>                                                   │
│                                                             │
│ Result:                                                     │
│ • Send button disabled when message empty                   │
│ • No empty messages stored in database                      │
└────────────────────────────────────────────────────────────┘

CASE 15: Rapid Message Sending (Throttling)
┌────────────────────────────────────────────────────────────┐
│ Scenario:                                                   │
│ User rapidly sends multiple messages                        │
│                                                             │
│ Handling:                                                   │
│ Chat.js:                                                   │
│                                                             │
│ const [sending, setSending] = useState(false);             │
│                                                             │
│ const handleSendMessage = async () => {                    │
│   if (sending) return; // Prevent double-send              │
│                                                             │
│   setSending(true);                                        │
│   try {                                                     │
│     await ChatMessage.create({...});                       │
│     setNewMessage('');                                     │
│   } catch (error) {                                        │
│     console.error("Error sending message:", error);        │
│   } finally {                                              │
│     setSending(false);                                     │
│   }                                                         │
│ };                                                          │
│                                                             │
│ <Button                                                     │
│   disabled={sending || !newMessage.trim()}                 │
│ >                                                           │
│   {sending ? 'Sending...' : 'Send'}                        │
│ </Button>                                                   │
│                                                             │
│ Result:                                                     │
│ • Button disabled while sending                             │
│ • Prevents duplicate messages                               │
│ • User sees "Sending..." feedback                           │
└────────────────────────────────────────────────────────────┘

══════════════════════════════════════════════════════════════
ADMIN EDGE CASES
══════════════════════════════════════════════════════════════

CASE 16: Non-Admin Accessing Admin Pages
┌────────────────────────────────────────────────────────────┐
│ Scenario:                                                   │
│ Regular user tries to access /admin or /rooms               │
│                                                             │
│ Protection:                                                 │
│ Admin.js & Rooms.js:                                       │
│                                                             │
│ useEffect(() => {                                          │
│   const user = await User.me();                            │
│   setCurrentUser(user);                                    │
│                                                             │
│   if (user.role !== 'admin') {                             │
│     setLoading(false);                                     │
│     return;                                                 │
│   }                                                         │
│                                                             │
│   // Load admin data                                       │
│ }, []);                                                     │
│                                                             │
│ if (currentUser?.role !== 'admin') {                       │
│   return (                                                  │
│     <div className="min-h-screen flex items-center justify-center">│
│       <Alert variant="destructive">                        │
│         <AlertCircle className="h-4 w-4" />                │
│         <AlertDescription>                                 │
│           <strong>Access Denied:</strong> This page is     │
│           restricted to administrators only.               │
│         </AlertDescription>                                 │
│       </Alert>                                              │
│     </div>                                                  │
│   );                                                        │
│ }                                                           │
│                                                             │
│ Layout.js:                                                 │
│ • "Admin Settings" menu item only shown if role === 'admin'│
│ • "Rooms" menu item only shown if role === 'admin'          │
│                                                             │
│ Result:                                                     │
│ • Non-admins see access denied message                      │
│ • Admin menu items hidden for regular users                 │
│ • Cannot bypass UI protections                              │
└────────────────────────────────────────────────────────────┘

CASE 17: Deleting Room with Active Bookings
┌────────────────────────────────────────────────────────────┐
│ Scenario:                                                   │
│ Admin tries to delete room that has upcoming bookings       │
│                                                             │
│ Prevention:                                                 │
│ Rooms.js:                                                  │
│                                                             │
│ const handleDeleteRoom = async (roomId) => {               │
│   // Check for active bookings                             │
│   const activeBookings = allBookings.filter(               │
│     b => b.room_id === roomId &&                           │
│          b.status === 'active' &&                          │
│          new Date(b.start_time) > new Date()               │
│   );                                                        │
│                                                             │
│   if (activeBookings.length > 0) {                         │
│     setError(                                              │
│       `Cannot delete room with ${activeBookings.length} ` +│
│       `active booking(s). Please cancel the bookings first `│
│       + `or deactivate the room instead.`                  │
│     );                                                      │
│     return;                                                 │
│   }                                                         │
│                                                             │
│   // Confirm deletion                                      │
│   if (!confirm('Are you sure you want to delete this room?')) {│
│     return;                                                 │
│   }                                                         │
│                                                             │
│   // Delete room                                           │
│   await VenueRoom.delete(roomId);                          │
│   await loadData();                                        │
│ };                                                          │
│                                                             │
│ Better approach: Suggest deactivation                      │
│ <Alert variant="warning">                                  │
│   This room has {activeBookings.length} upcoming bookings. │
│   Consider deactivating the room instead of deleting it.   │
│   [Deactivate Room] [Cancel]                               │
│ </Alert>                                                    │
│                                                             │
│ Result:                                                     │
│ • Cannot delete room with active bookings                   │
│ • Clear error message shown                                 │
│ • Suggests deactivation as alternative                      │
└────────────────────────────────────────────────────────────┘

CASE 18: Admin Removing Own Admin Role
┌────────────────────────────────────────────────────────────┐
│ Scenario:                                                   │
│ Admin tries to remove their own admin privileges            │
│                                                             │
│ Prevention:                                                 │
│ Admin.js:                                                  │
│                                                             │
│ {delegate.role === 'admin' &&                              │
│  delegate.id !== currentUser?.id && (                      │
│   <Button                                                   │
│     size="sm"                                              │
│     variant="outline"                                      │
│     onClick={() => updateDelegateRole(delegate.id, 'user')}│
│   >                                                         │
│     Remove Admin                                           │
│   </Button>                                                 │
│ )}                                                          │
│                                                             │
│ Logic:                                                      │
│ • "Remove Admin" button only shown for OTHER admins         │
│ • Current user's own role cannot be changed via UI          │
│                                                             │
│ Protection Reason:                                         │
│ • Prevents accidental lock-out                              │
│ • Ensures at least one admin always exists                  │
│ • Admin must ask another admin to change their role         │
│                                                             │
│ Result:                                                     │
│ • Cannot self-remove admin privileges                       │
│ • Requires another admin to make changes                    │
└────────────────────────────────────────────────────────────┘

══════════════════════════════════════════════════════════════
NOTIFICATION EDGE CASES
══════════════════════════════════════════════════════════════

CASE 19: Notification for Disabled Preference
┌────────────────────────────────────────────────────────────┐
│ Scenario:                                                   │
│ User has disabled meeting request notifications             │
│                                                             │
│ Handling:                                                   │
│ Before creating notification:                               │
│                                                             │
│ const recipient = await User.get(recipientId);             │
│                                                             │
│ // Check preferences                                       │
│ const preferences = recipient.notification_preferences || {}; │
│                                                             │
│ if (preferences.new_meeting_request !== false) {           │
│   // Create notification                                   │
│   await Notification.create({                              │
│     user_id: recipientId,                                  │
│     type: 'new_meeting_request',                           │
│     title: 'New Meeting Request',                          │
│     body: `...`,                                           │
│     link: '/meetings'                                      │
│   });                                                       │
│ }                                                           │
│                                                             │
│ Logic:                                                      │
│ • If preference === false → Don't create notification       │
│ • If preference === true or undefined → Create notification│
│ • Default behavior: Send all notifications                  │
│                                                             │
│ Result:                                                     │
│ • Respects user preferences                                 │
│ • No notifications for disabled types                       │
│ • User has full control                                     │
└────────────────────────────────────────────────────────────┘

CASE 20: Notification for Deleted Entity
┌────────────────────────────────────────────────────────────┐
│ Scenario:                                                   │
│ User clicks notification but related entity was deleted     │
│                                                             │
│ Handling:                                                   │
│ When user clicks notification:                             │
│                                                             │
│ <Link                                                       │
│   to={notification.link || '#'}                            │
│   onClick={() => handleMarkAsRead(notification.id)}        │
│ >                                                           │
│                                                             │
│ Target page (e.g., Meetings.js):                           │
│ useEffect(() => {                                          │
│   const requestId = urlParams.get('id');                   │
│   if (requestId) {                                         │
│     try {                                                   │
│       const meeting = await MeetingRequest.get(requestId); │
│       setHighlightedMeeting(meeting);                      │
│     } catch (error) {                                      │
│       // Entity not found                                  │
│       setError("This meeting no longer exists.");          │
│     }                                                       │
│   }                                                         │
│ }, []);                                                     │
│                                                             │
│ UI Feedback:                                               │
│ <Alert variant="info">                                     │
│   The item you're looking for may have been cancelled or   │
│   deleted.                                                  │
│ </Alert>                                                    │
│                                                             │
│ Result:                                                     │
│ • Graceful handling of missing entities                     │
│ • Clear message to user                                     │
│ • No application crash                                      │
└────────────────────────────────────────────────────────────┘
13. UI/UX Specifications
┌─────────────────────────────────────────────────────────────┐
│              UI/UX DESIGN SYSTEM                             │
└─────────────────────────────────────────────────────────────┘

══════════════════════════════════════════════════════════════
COLOR PALETTE
══════════════════════════════════════════════════════════════

Primary Colors (Defined in Layout.js):
┌────────────────────────────────────────────────────────────┐
│ :root {                                                     │
│   --primary-50: #f8fafc;   /* Lightest background */       │
│   --primary-100: #f1f5f9;  /* Light background */          │
│   --primary-200: #e2e8f0;  /* Subtle borders */            │
│   --primary-300: #cbd5e1;  /* Disabled elements */         │
│   --primary-400: #94a3b8;  /* Secondary text */            │
│   --primary-500: #64748b;  /* Primary gray */              │
│   --primary-600: #475569;  /* Darker text */               │
│   --primary-700: #334155;  /* Headings */                  │
│   --primary-800: #1e293b;  /* Dark headings */             │
│   --primary-900: #0f172a;  /* Darkest text */              │
│                                                             │
│   --accent-500: #3b82f6;   /* Primary blue */              │
│   --accent-600: #2563eb;   /* Hover blue */                │
│   --accent-700: #1d4ed8;   /* Active blue */               │
│ }                                                           │
│                                                             │
│ Semantic Colors:                                            │
│ • Success: green-500 (#22c55e)                              │
│ • Warning: orange-500 (#f97316)                             │
│ • Error: red-500 (#ef4444)                                  │
│ • Info: blue-500 (#3b82f6)                                  │
└────────────────────────────────────────────────────────────┘

Background Gradients:
┌────────────────────────────────────────────────────────────┐
│ All main content pages use:                                │
│ className="min-h-screen bg-gradient-to-br                  │
│            from-slate-50 to-blue-50"                       │
│                                                             │
│ Effect: Subtle gradient from light gray to light blue      │
│ Purpose: Modern, clean look without overwhelming users     │
└────────────────────────────────────────────────────────────┘

══════════════════════════════════════════════════════════════
TYPOGRAPHY
══════════════════════════════════════════════════════════════

Font System:
┌────────────────────────────────────────────────────────────┐
│ Default: System font stack (handled by Tailwind)           │
│ • -apple-system, BlinkMacSystemFont, "Segoe UI", ...       │
│                                                             │
│ Hierarchy:                                                  │
│                                                             │
│ Page Titles:                                               │
│ • text-3xl font-bold text-slate-900                        │
│ • Example: "Meeting Management", "User Profile"            │
│                                                             │
│ Section Titles:                                            │
│ • text-xl font-semibold text-slate-900                     │
│ • Example: "Basic Information", "Topical Interests"        │
│                                                             │
│ Card Titles:                                               │
│ • text-lg font-semibold text-slate-900                     │
│ • Example: Room names, meeting topics                      │
│                                                             │
│ Body Text:                                                  │
│ • text-base text-slate-700                                 │
│ • Line height: leading-normal (1.5)                        │
│                                                             │
│ Secondary Text:                                            │
│ • text-sm text-slate-600                                   │
│ • Used for descriptions, metadata                          │
│                                                             │
│ Captions:                                                   │
│ • text-xs text-slate-500                                   │
│ • Used for timestamps, hints                               │
└────────────────────────────────────────────────────────────┘

══════════════════════════════════════════════════════════════
COMPONENT STYLING
══════════════════════════════════════════════════════════════

Cards (Shadcn UI Component):
┌────────────────────────────────────────────────────────────┐
│ Standard Card:                                             │
│ <Card className="bg-white/80 backdrop-blur-sm border-0    │
│                 shadow-lg">                                │
│   <CardHeader>...</CardHeader>                             │
│   <CardContent>...</CardContent>                           │
│ </Card>                                                     │
│                                                             │
│ Visual Properties:                                         │
│ • Semi-transparent white background (80% opacity)           │
│ • Backdrop blur effect (modern glass morphism)              │
│ • No border (border-0)                                      │
│ • Large shadow (shadow-lg)                                  │
│ • Rounded corners (default from Shadcn: rounded-lg)         │
│                                                             │
│ Hover Effects:                                             │
│ className="hover:shadow-xl hover:-translate-y-1            │
│            transition-all duration-300"                    │
│ • Shadow increases on hover                                 │
│ • Card lifts up slightly (translate-y)                      │
│ • Smooth 300ms transition                                   │
└────────────────────────────────────────────────────────────┘

Buttons:
┌────────────────────────────────────────────────────────────┐
│ Primary Button:                                            │
│ <Button className="bg-blue-600 hover:bg-blue-700">        │
│   Action Text                                              │
│ </Button>                                                   │
│                                                             │
│ Secondary Button:                                          │
│ <Button variant="outline">                                 │
│   Action Text                                              │
│ </Button>                                                   │
│                                                             │
│ Destructive Button:                                        │
│ <Button variant="destructive">                             │
│   Delete                                                   │
│ </Button>                                                   │
│                                                             │
│ Ghost Button (minimal):                                    │
│ <Button variant="ghost">                                   │
│   Cancel                                                   │
│ </Button>                                                   │
│                                                             │
│ Disabled State:                                            │
│ <Button disabled={condition}>                              │
│   {loading ? 'Loading...' : 'Submit'}                      │
│ </Button>                                                   │
│ • Grayed out automatically                                  │
│ • Cursor: not-allowed                                       │
│ • No hover effects                                          │
└────────────────────────────────────────────────────────────┘

Badges:
┌────────────────────────────────────────────────────────────┐
│ Status Badges:                                             │
│                                                             │
│ Pending:                                                   │
│ <Badge className="bg-orange-100 text-orange-800">          │
│   Pending                                                  │
│ </Badge>                                                    │
│                                                             │
│ Active/Accepted:                                           │
│ <Badge className="bg-green-100 text-green-800">            │
│   Active                                                   │
│ </Badge>                                                    │
│                                                             │
│ Declined/Cancelled:                                        │
│ <Badge className="bg-red-100 text-red-800">                │
│   Cancelled                                                │
│ </Badge>                                                    │
│                                                             │
│ Info:                                                       │
│ <Badge variant="outline">                                  │
│   Code: A7K9M2N4                                           │
│ </Badge>                                                    │
│                                                             │
│ Priority Badges:                                           │
│ High: bg-red-100 text-red-800                              │
│ Medium: bg-orange-100 text-orange-800                      │
│ Low: bg-blue-100 text-blue-800                             │
└────────────────────────────────────────────────────────────┘

Inputs & Forms:
┌────────────────────────────────────────────────────────────┐
│ Text Input:                                                │
│ <Input                                                      │
│   placeholder="Enter text..."                             │
│   value={value}                                            │
│   onChange={(e) => setValue(e.target.value)}               │
│   className="..."  // Additional styling if needed         │
│ />                                                          │
│                                                             │
│ Textarea:                                                   │
│ <Textarea                                                   │
│   placeholder="Enter description..."                       │
│   className="h-24"  // Custom height                       │
│ />                                                          │
│                                                             │
│ Select Dropdown:                                           │
│ <Select value={value} onValueChange={setValue}>            │
│   <SelectTrigger>                                          │
│     <SelectValue placeholder="Select option" />            │
│   </SelectTrigger>                                          │
│   <SelectContent>                                          │
│     <SelectItem value="option1">Option 1</SelectItem>      │
│     <SelectItem value="option2">Option 2</SelectItem>      │
│   </SelectContent>                                          │
│ </Select>                                                   │
│                                                             │
│ Checkbox:                                                   │
│ <Checkbox                                                   │
│   id="consent"                                             │
│   checked={checked}                                        │
│   onCheckedChange={setChecked}                             │
│ />                                                          │
│ <Label htmlFor="consent">I agree to terms</Label>          │
│                                                             │
│ Switch Toggle:                                             │
│ <Switch                                                     │
│   checked={enabled}                                        │
│   onCheckedChange={setEnabled}                             │
│ />                                                          │
└────────────────────────────────────────────────────────────┘

Alerts:
┌────────────────────────────────────────────────────────────┐
│ Info Alert:                                                │
│ <Alert className="border-blue-200 bg-blue-50">             │
│   <AlertCircle className="h-4 w-4 text-blue-600" />        │
│   <AlertDescription className="text-blue-800">            │
│     Informational message here                            │
│   </AlertDescription>                                       │
│ </Alert>                                                    │
│                                                             │
│ Warning Alert:                                             │
│ <Alert className="border-orange-200 bg-orange-50">         │
│   <AlertCircle className="h-4 w-4 text-orange-600" />      │
│   <AlertDescription className="text-orange-800">          │
│     Warning message here                                  │
│   </AlertDescription>                                       │
│ </Alert>                                                    │
│                                                             │
│ Error Alert:                                               │
│ <Alert variant="destructive">                              │
│   <AlertCircle className="h-4 w-4" />                      │
│   <AlertDescription>                                       │
│     Error message here                                    │
│   </AlertDescription>                                       │
│ </Alert>                                                    │
│                                                             │
│ Success Alert:                                             │
│ <Alert className="border-green-200 bg-green-50">           │
│   <CheckCircle2 className="h-4 w-4 text-green-600" />      │
│   <AlertDescription className="text-green-800">           │
│     Success message here                                  │
│   </AlertDescription>                                       │
│ </Alert>                                                    │
└────────────────────────────────────────────────────────────┘

══════════════════════════════════════════════════════════════
LAYOUT STRUCTURE
══════════════════════════════════════════════════════════════

Overall Layout:
┌────────────────────────────────────────────────────────────┐
│ ┌────────────┬─────────────────────────────────────────┐  │
│ │            │  HEADER (Sticky)                        │  │
│ │            │  [Page Title]      [User] [🔔] [⚙️]    │  │
│ │            ├─────────────────────────────────────────┤  │
│ │            │                                         │  │
│ │  SIDEBAR   │                                         │  │
│ │  (Fixed)   │         MAIN CONTENT AREA              │  │
│ │            │                                         │  │
│ │            │         (Scrollable)                    │  │
│ │            │                                         │  │
│ │            │                                         │  │
│ │            │                                         │  │
│ └────────────┴─────────────────────────────────────────┘  │
│                                                             │
│ Responsive Behavior:                                       │
│ • Desktop (>= 1024px): Sidebar always visible              │
│ • Tablet/Mobile (< 1024px): Sidebar hidden, hamburger menu │
│ • Header sticky on scroll                                  │
│ • Content area: max-width-7xl (1280px) centered            │
└────────────────────────────────────────────────────────────┘

Sidebar:
┌────────────────────────────────────────────────────────────┐
│ Width: 320px (w-80)                                        │
│ Background: white                                          │
│ Border: Right border (border-r border-gray-200/60)         │
│                                                             │
│ Structure:                                                  │
│ ┌──────────────────────────────────────────────────────┐  │
│ │ Logo Section (p-8)                                    │  │
│ │ [🛡️ Icon] UNIConnect                                  │  │
│ │           Professional Network                        │  │
│ ├──────────────────────────────────────────────────────┤  │
│ │ Navigation (flex-1, px-6, py-8)                       │  │
│ │ ┌────────────────────────────────────────────────┐   │  │
│ │ │ 📊 Dashboard                                    │   │  │
│ │ │ 📅 My Schedule                                  │   │  │
│ │ │ 👥 Delegates                                    │   │  │
│ │ │ 📅 Meetings                                     │   │  │
│ │ │ 💬 Chat                                         │   │  │
│ │ │ 🛡️ Admin Settings (admin only)                 │   │  │
│ │ └────────────────────────────────────────────────┘   │  │
│ └──────────────────────────────────────────────────────┘  │
│                                                             │
│ Nav Item Styling:                                          │
│ • Inactive: text-gray-600, hover:bg-gray-50                │
│ • Active: bg-blue-50, text-blue-700                        │
│ • Left border indicator on active (blue-500, 3px height)   │
│ • Smooth transitions                                        │
│ • Icon + text layout with gap                              │
└────────────────────────────────────────────────────────────┘

Header:
┌────────────────────────────────────────────────────────────┐
│ Height: 73px (py-4)                                        │
│ Background: white/80 with backdrop-blur-md                 │
│ Border: Bottom border (border-b border-gray-200/60)        │
│ Position: Sticky top-0                                     │
│                                                             │
│ Layout:                                                     │
│ [☰ Menu (mobile)] [Page Title]    [🔔] [User Menu ▼]     │
│                                                             │
│ Left Side:                                                 │
│ • Hamburger menu (mobile only)                             │
│ • Current page title                                       │
│                                                             │
│ Right Side:                                                │
│ • NotificationBell component                               │
│ • User dropdown menu:                                      │
│   - User avatar (initial in colored circle)                │
│   - User name (first name only on small screens)           │
│   - Dropdown arrow                                         │
│   - Menu items: Profile, Sign out                          │
└────────────────────────────────────────────────────────────┘

Content Area Padding:
┌────────────────────────────────────────────────────────────┐
│ All content pages use:                                     │
│ <div className="p-4 md:p-8">                               │
│   <div className="max-w-7xl mx-auto space-y-8">           │
│     {/* Page content */}                                   │
│   </div>                                                    │
│ </div>                                                      │
│                                                             │
│ • Padding: 1rem mobile, 2rem desktop                       │
│ • Max width: 1280px                                        │
│ • Centered with mx-auto                                    │
│ • Vertical spacing: 2rem between sections (space-y-8)      │
└────────────────────────────────────────────────────────────┘

══════════════════════════════════════════════════════════════
RESPONSIVE DESIGN
══════════════════════════════════════════════════════════════

Breakpoints (Tailwind Default):
┌────────────────────────────────────────────────────────────┐
│ sm:  640px  (Small tablets, large phones)                  │
│ md:  768px  (Tablets)                                      │
│ lg:  1024px (Small desktops, large tablets)                │
│ xl:  1280px (Desktops)                                     │
│ 2xl: 1536px (Large desktops)                               │
└────────────────────────────────────────────────────────────┘

Grid Layouts:
┌────────────────────────────────────────────────────────────┐
│ Stats Cards (Dashboard):                                   │
│ grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-6      │
│ • Mobile: 1 column                                         │
│ • Tablet: 2 columns                                        │
│ • Desktop: 4 columns                                       │
│                                                             │
│ Room Cards (Rooms page):                                   │
│ grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6      │
│ • Mobile: 1 column                                         │
│ • Tablet: 2 columns                                        │
│ • Desktop: 3 columns                                       │
│                                                             │
│ Form Fields (Profile):                                     │
│ grid grid-cols-1 md:grid-cols-2 gap-6                     │
│ • Mobile: 1 column (stacked)                               │
│ • Tablet+: 2 columns (side-by-side)                        │
└────────────────────────────────────────────────────────────┘

Mobile Navigation:
┌────────────────────────────────────────────────────────────┐
│ < 1024px:                                                  │
│ • Sidebar hidden by default                                │
│ • Hamburger menu button visible in header                  │
│ • Click hamburger → Sidebar slides in from left            │
│ • Backdrop overlay appears (semi-transparent black)        │
│ • Click outside sidebar or backdrop → Closes sidebar       │
│                                                             │
│ Implementation:                                             │
│ const [sidebarOpen, setSidebarOpen] = useState(false);     │
│                                                             │
│ // Sidebar                                                 │
│ <aside className={`fixed top-0 left-0 h-full z-50         │
│   transition-transform duration-300                        │
│   ${sidebarOpen ? 'translate-x-0' : '-translate-x-full'}   │
│   lg:translate-x-0`}>                                      │
│                                                             │
│ // Backdrop                                                │
│ {sidebarOpen && (                                          │
│   <div                                                      │
│     className="fixed inset-0 bg-black/20 backdrop-blur-sm │
│                z-40 lg:hidden"                             │
│     onClick={() => setSidebarOpen(false)}                  │
│   />                                                        │
│ )}                                                          │
└────────────────────────────────────────────────────────────┘

Text Sizing:
┌────────────────────────────────────────────────────────────┐
│ Headings scale responsively:                               │
│                                                             │
│ Main Page Title:                                           │
│ text-2xl md:text-3xl font-bold                             │
│ • Mobile: 1.5rem (24px)                                    │
│ • Desktop: 1.875rem (30px)                                 │
│                                                             │
│ Card Titles:                                               │
│ text-lg md:text-xl font-semibold                           │
│ • Mobile: 1.125rem (18px)                                  │
│ • Desktop: 1.25rem (20px)                                  │
└────────────────────────────────────────────────────────────┘

══════════════════════════════════════════════════════════════
LOADING STATES
══════════════════════════════════════════════════════════════

Skeleton Loading:
┌────────────────────────────────────────────────────────────┐
│ Used while data is loading:                                │
│                                                             │
│ {loading ? (                                               │
│   <div className="animate-pulse space-y-6">                │
│     <div className="h-8 bg-slate-200 rounded w-64"></div>  │
│     <div className="grid grid-cols-1 md:grid-cols-4 gap-6">│
│       {[1,2,3,4].map(i => (                                │
│         <div key={i} className="h-32 bg-slate-200         │
│                                 rounded-xl"></div>         │
│       ))}                                                   │
│     </div>                                                  │
│   </div>                                                    │
│ ) : (                                                       │
│   {/* Actual content */}                                   │
│ )}                                                          │
│                                                             │
│ Visual Effect:                                             │
│ • Gray placeholder boxes                                    │
│ • Pulse animation (opacity 0.5 → 1.0)                      │
│ • Matches layout of actual content                         │
└────────────────────────────────────────────────────────────┘

Button Loading:
┌────────────────────────────────────────────────────────────┐
│ <Button onClick={handleSave} disabled={saving}>            │
│   {saving ? (                                              │
│     <>                                                      │
│       <div className="animate-spin rounded-full h-4 w-4   │
│                       border-b-2 border-white mr-2" />     │
│       Saving...                                            │
│     </>                                                     │
│   ) : (                                                     │
│     <>                                                      │
│       <Save className="w-4 h-4 mr-2" />                    │
│       Save                                                 │
│     </>                                                     │
│   )}                                                        │
│ </Button>                                                   │
│                                                             │
│ Visual Effect:                                             │
│ • Spinner icon rotates continuously                         │
│ • Text changes to "Saving..."                               │
│ • Button disabled during operation                          │
└────────────────────────────────────────────────────────────┘

Empty States:
┌────────────────────────────────────────────────────────────┐
│ When no data to display:                                   │
│                                                             │
│ <Card>                                                      │
│   <CardContent className="p-12 text-center">               │
│     <Calendar className="w-16 h-16 text-slate-300         │
│                          mx-auto mb-4" />                  │
│     <h3 className="text-lg font-medium text-slate-900     │
│                    mb-2">                                  │
│       No meetings found                                    │
│     </h3>                                                   │
│     <p className="text-slate-600">                         │
│       Your meetings will appear here once you connect      │
│       with other delegates.                                │
│     </p>                                                    │
│   </CardContent>                                            │
│ </Card>                                                     │
│                                                             │
│ Components:                                                 │
│ • Large icon (16x16, light gray)                           │
│ • Heading explaining no data                               │
│ • Descriptive text or call-to-action                       │
│ • Centered layout                                          │
│ • Generous padding (p-12)                                  │
└────────────────────────────────────────────────────────────┘

══════════════════════════════════════════════════════════════
ACCESSIBILITY
══════════════════════════════════════════════════════════════

Keyboard Navigation:
┌────────────────────────────────────────────────────────────┐
│ • All interactive elements focusable                        │
│ • Tab order follows visual flow                            │
│ • Focus indicators visible (Shadcn default: blue ring)      │
│ • Enter/Space to activate buttons                          │
│ • Escape to close dialogs                                  │
│ • Arrow keys in dropdowns/selects                          │
└────────────────────────────────────────────────────────────┘

Screen Reader Support:
┌────────────────────────────────────────────────────────────┐
│ • Semantic HTML (header, main, nav, aside)                  │
│ • Proper heading hierarchy (h1 → h2 → h3)                  │
│ • Alt text on icons (lucide-react provides aria-hidden)     │
│ • Form labels associated with inputs                        │
│ • ARIA labels on icon-only buttons                         │
│                                                             │
│ Example:                                                    │
│ <Button aria-label="Close dialog" onClick={onClose}>       │
│   <X className="w-4 h-4" />                                │
│ </Button>                                                   │
└────────────────────────────────────────────────────────────┘

Color Contrast:
┌────────────────────────────────────────────────────────────┐
│ All text meets WCAG AA standards (4.5:1 minimum):          │
│ • Dark text on light backgrounds                            │
│ • Light text on dark backgrounds                            │
│ • Sufficient contrast in colored badges                     │
│ • Status indicators use both color AND text                 │
└────────────────────────────────────────────────────────────┘

══════════════════════════════════════════════════════════════
ANIMATION & TRANSITIONS
══════════════════════════════────════════════════════════════

Standard Transitions:
┌────────────────────────────────────────────────────────────┐
│ duration-300: Most UI transitions (0.3s)                   │
│ duration-200: Fast feedback (0.2s)                         │
│ duration-500: Complex animations (0.5s)                    │
│                                                             │
│ Easing: cubic-bezier(0.4, 0, 0.2, 1) (ease-out)           │
│ • Smooth, natural feeling                                  │
│ • Fast start, slow end                                     │
└────────────────────────────────────────────────────────────┘

Hover Effects:
┌────────────────────────────────────────────────────────────┐
│ Cards:                                                      │
│ hover:shadow-xl hover:-translate-y-1 transition-all        │
│ • Shadow increases                                         │
│ • Lifts 4px upward                                         │
│                                                             │
│ Buttons:                                                    │
│ hover:bg-blue-700 transition-colors                        │
│ • Background color darkens                                 │
│ • Smooth color transition                                  │
│                                                             │
│ Nav Items:                                                  │
│ hover:bg-gray-50 transition-colors                         │
│ • Subtle background change                                  │
└────────────────────────────────────────────────────────────┘

Dialog Animations:
┌────────────────────────────────────────────────────────────┐
│ Provided by Shadcn Dialog component:                       │
│ • Fade in/out (opacity)                                    │
│ • Scale in from center (scale 0.95 → 1.0)                  │
│ • Backdrop fade in                                         │
│ • 200ms duration                                           │
└────────────────────────────────────────────────────────────┘
14. Performance Optimization
┌─────────────────────────────────────────────────────────────┐
│          PERFORMANCE OPTIMIZATION STRATEGIES                 │
└─────────────────────────────────────────────────────────────┘

══════════════════════════════════════════════════════════════
DATA FETCHING OPTIMIZATION
══════════════════════════════════════════════════════════════

Parallel Loading:
┌────────────────────────────────────────────────────────────┐
│ Load independent data simultaneously:                       │
│                                                             │
│ const loadDashboardData = async () => {                    │
│   const [                                                   │
│     user,                                                   │
│     meetings,                                              │
│     messages,                                              │
│     bookings,                                              │
│     users                                                   │
│   ] = await Promise.all([                                  │
│     User.me(),                                             │
│     MeetingRequest.list('-created_date'),                  │
│     ChatMessage.list('-created_date'),                     │
│     VenueBooking.list('-created_date'),                    │
│     User.list()                                            │
│   ]);                                                       │
│                                                             │
│   // Process data...                                       │
│ };                                                          │
│                                                             │
│ Benefits:                                                   │
│ • Reduces total loading time                                │
│ • All requests start immediately                            │
│ • Page loads faster                                        │
│                                                             │
│ Example timing:                                            │
│ Sequential: 1s + 1s + 1s + 1s + 1s = 5s total              │
│ Parallel: max(1s, 1s, 1s, 1s, 1s) = 1s total              │
└────────────────────────────────────────────────────────────┘

Pagination & Limiting:
┌────────────────────────────────────────────────────────────┐
│ Limit query results to prevent large data loads:           │
│                                                             │
│ // Limit to most recent 20 notifications                   │
│ const notifications = await Notification.filter(           │
│   { user_id: currentUser.id },                             │
│   '-created_date',                                         │
│   20  // ← Limit parameter                                │
│ );                                                          │
│                                                             │
│ // Load delegates in batches if needed                     │
│ const firstBatch = await User.list('-created_date', 50);   │
│                                                             │
│ Benefits:                                                   │
│ • Faster initial page load                                  │
│ • Less memory usage                                         │
│ • Better user experience                                    │
│                                                             │
│ Note: Full lists loaded for filtering purposes where needed│
└────────────────────────────────────────────────────────────┘

Caching User Lookups:
┌────────────────────────────────────────────────────────────┐
│ Create user lookup map once, reuse everywhere:             │
│                                                             │
│ // Load all users once                                     │
│ const allUsers = await User.list();                        │
│                                                             │
│ // Create lookup object                                    │
│ const userLookup = {};                                     │
│ allUsers.forEach(u => {                                    │
│   userLookup[u.id] = u;                                    │
│ });                                                         │
│ setUsers(userLookup);                                      │
│                                                             │
│ // Later: O(1) lookup instead of O(n) search               │
│ const userName = users[userId]?.full_name;                 │
│                                                             │
│ vs. Inefficient approach:                                  │
│ const user = allUsers.find(u => u.id === userId); // O(n)  │
│                                                             │
│ Benefits:                                                   │
│ • Constant time lookups                                     │
│ • No repeated API calls                                     │
│ • Better performance with many users                        │
└────────────────────────────────────────────────────────────┘

══════════════════════════════════════════════════════════════
RENDERING OPTIMIZATION
══════════════════════════════════════════════════════════════

Conditional Rendering:
┌────────────────────────────────────────────────────────────┐
│ Render only necessary components:                          │
│                                                             │
│ {/* Don't render until data loaded */}                     │
│ {loading ? (                                               │
│   <SkeletonLoader />                                       │
│ ) : (                                                       │
│   <ActualContent />                                        │
│ )}                                                          │
│                                                             │
│ {/* Don't render admin components for non-admins */}       │
│ {currentUser?.role === 'admin' && (                        │
│   <AdminControls />                                        │
│ )}                                                          │
│                                                             │
│ {/* Only render notification bell if authenticated */}     │
│ {currentUser && <NotificationBell />}                      │
│                                                             │
│ Benefits:                                                   │
│ • Less DOM nodes to render                                  │
│ • Faster initial render                                     │
│ • Reduced memory usage                                      │
└────────────────────────────────────────────────────────────┘

Memoization (Not Currently Implemented):
┌────────────────────────────────────────────────────────────┐
│ Could add React.useMemo for expensive calculations:        │
│                                                             │
│ const filteredDelegates = React.useMemo(() => {            │
│   return allDelegates.filter(delegate =>                   │
│     delegate.profile_completed &&                          │
│     delegate.consent_given &&                              │
│     !delegate.is_profile_hidden &&                         │
│     delegate.id !== currentUser?.id                        │
│   );                                                        │
│ }, [allDelegates, currentUser]);                           │
│                                                             │
│ Benefits:                                                   │
│ • Recalculates only when dependencies change                │
│ • Prevents unnecessary filtering on every render            │
│                                                             │
│ Note: Not critical for current scale (< 1000 users)        │
└────────────────────────────────────────────────────────────┘

Virtual Scrolling (Future Enhancement):
┌────────────────────────────────────────────────────────────┐
│ For very long lists (1000+ items), could implement:        │
│                                                             │
│ • react-window or react-virtualized                        │
│ • Only renders visible items + buffer                      │
│ • Dramatically improves performance                         │
│                                                             │
│ Example scenario:                                          │
│ • Conference with 10,000 delegates                         │
│ • Chat with 5,000 messages                                 │
│ • Room with 500 bookings                                   │
│                                                             │
│ Currently: Not needed for typical scale (50-500 items)     │
└────────────────────────────────────────────────────────────┘

══════════════════════════════════════════════════════════════
REAL-TIME UPDATE OPTIMIZATION
══════════════════════════════════════════════════════════════

Polling Strategy:
┌────────────────────────────────────────────────────────────┐
│ NotificationBell Component:                                │
│                                                             │
│ useEffect(() => {                                          │
│   if (!currentUser) return;                                │
│                                                             │
│   const fetchNotifications = async () => {                 │
│     const fetched = await Notification.filter(             │
│       { user_id: currentUser.id },                         │
│       '-created_date',                                     │
│       20                                                    │
│     );                                                      │
│     setNotifications(fetched);                             │
│   };                                                        │
│                                                             │
│   fetchNotifications(); // Initial fetch                   │
│   const interval = setInterval(                            │
│     fetchNotifications,                                    │
│     15000  // Poll every 15 seconds                        │
│   );                                                        │
│                                                             │
│   return () => clearInterval(interval); // Cleanup         │
│ }, [currentUser]);                                         │
│                                                             │
│ Optimization:                                              │
│ • Only polls when component mounted                         │
│ • Stops polling when component unmounts                     │
│ • 15s interval balances freshness vs. load                  │
│                                                             │
│ Alternative (Not Implemented): WebSocket                   │
│ • Real-time push updates                                   │
│ • More complex infrastructure                              │
│ • Better for high-frequency updates                         │
└────────────────────────────────────────────────────────────┘

Smart Refresh:
┌────────────────────────────────────────────────────────────┐
│ Only refresh when needed:                                  │
│                                                             │
│ // After user action, refresh relevant data                │
│ const handleAcceptMeeting = async (meetingId) => {         │
│   await MeetingRequest.update(meetingId, {                 │
│     status: 'accepted'                                     │
│   });                                                       │
│                                                             │
│   await loadMeetings(); // Refresh meetings only           │
│   // Don't refresh users, rooms, etc.                      │
│ };                                                          │
│                                                             │
│ Benefits:                                                   │
│ • Faster refresh                                           │
│ • Less API traffic                                         │
│ • Better user experience                                    │
└────────────────────────────────────────────────────────────┘

══════════════════════════════════════════════════════════════
BUNDLE SIZE OPTIMIZATION
══════════════════════════════════════════════════════════════

Code Splitting (Automatic with React):
┌────────────────────────────────────────────────────────────┐
│ React Router automatically code-splits by route:           │
│                                                             │
│ /dashboard → Dashboard.js bundle                           │
│ /profile → Profile.js bundle                               │
│ /meetings → Meetings.js bundle                             │
│ etc.                                                        │
│                                                             │
│ Benefits:                                                   │
│ • Initial bundle smaller                                    │
│ • Pages load on-demand                                      │
│ • Faster first contentful paint                             │
└────────────────────────────────────────────────────────────┘

Icon Imports (Tree-shaking):
┌────────────────────────────────────────────────────────────┐
│ Import only used icons:                                    │
│                                                             │
│ // ✅ Good - only imports specific icons                   │
│ import { Calendar, User, Bell } from "lucide-react";       │
│                                                             │
│ // ❌ Bad - imports entire library                         │
│ import * as Icons from "lucide-react";                     │
│                                                             │
│ Benefits:                                                   │
│ • Smaller bundle size                                       │
│ • Faster page loads                                         │
│ • Webpack tree-shaking removes unused icons                 │
└────────────────────────────────────────────────────────────┘

Image Optimization:
┌────────────────────────────────────────────────────────────┐
│ • Use appropriate formats (WebP for photos, SVG for icons) │
│ • Compress images before upload                             │
│ • Use responsive images with srcset                         │
│ • Lazy load images below fold                               │
│                                                             │
│ Example:                                                    │
│ <img                                                        │
│   src="/image.webp"                                        │
│   loading="lazy"                                           │
│   alt="Description"                                        │
│ />                                                          │
│                                                             │
│ Note: User avatars use CSS (colored circles with initials) │
│ No image assets needed                                     │
└────────────────────────────────────────────────────────────┘

══════════════════════════════════════════════════════════════
NETWORK OPTIMIZATION
══════════════════════════════════════════════════════════════

HTTP/2:
┌────────────────────────────────────────────────────────────┐
│ Base44 platform serves over HTTP/2:                        │
│ • Multiplexing (parallel requests)                          │
│ • Header compression                                        │
│ • Server push (for critical resources)                      │
│                                                             │
│ Benefits:                                                   │
│ • Faster page loads                                         │
│ • Better use of connections                                 │
│ • Reduced latency                                          │
└────────────────────────────────────────────────────────────┘

CDN Delivery:
┌────────────────────────────────────────────────────────────┐
│ All static assets served from CDN:                         │
│ • JavaScript bundles                                        │
│ • CSS stylesheets                                          │
│ • Images and icons                                         │
│ • Fonts                                                     │
│                                                             │
│ Benefits:                                                   │
│ • Global distribution                                       │
│ • Edge caching                                             │
│ • Reduced server load                                       │
│ • Faster for international users                            │
└────────────────────────────────────────────────────────────┘

Compression:
┌────────────────────────────────────────────────────────────┐
│ All responses compressed:                                  │
│ • Gzip for text assets (HTML, CSS, JS, JSON)               │
│ • Brotli where supported (better compression)               │
│                                                             │
│ Example savings:                                           │
│ • Uncompressed JS: 500 KB                                  │
│ • Gzipped: 150 KB (70% reduction)                          │
│ • Brotli: 120 KB (76% reduction)                           │
└────────────────────────────────────────────────────────────┘

══════════════════════════════════════════════════════════════
PERCEIVED PERFORMANCE
══════════════════════════════════════════════════════════════

Skeleton Screens:
┌────────────────────────────────────────────────────────────┐
│ Show placeholder content while loading:                    │
│                                                             │
│ <div className="animate-pulse space-y-4">                  │
│   <div className="h-8 bg-slate-200 rounded w-64"></div>    │
│   <div className="h-32 bg-slate-200 rounded"></div>        │
│   <div className="h-32 bg-slate-200 rounded"></div>        │
│ </div>                                                      │
│                                                             │
│ Psychology:                                                 │
│ • User sees instant feedback                                │
│ • Feels faster than blank screen                            │
│ • Reduces perceived wait time by 20-30%                     │
└────────────────────────────────────────────────────────────┘

Optimistic UI Updates:
┌────────────────────────────────────────────────────────────┐
│ Update UI immediately, confirm later:                      │
│                                                             │
│ const handleMarkAsRead = async (notificationId) => {       │
│   // Update UI immediately                                 │
│   setNotifications(prev => prev.map(n =>                   │
│     n.id === notificationId ? {...n, is_read: true} : n    │
│   ));                                                       │
│                                                             │
│   // Confirm with server                                   │
│   await Notification.update(notificationId, {              │
│     is_read: true                                          │
│   });                                                       │
│                                                             │
│   // If fails, could revert:                               │
│   // setNotifications(prev => ...revert)                   │
│ };                                                          │
│                                                             │
│ Benefits:                                                   │
│ • Instant feedback                                         │
│ • Feels more responsive                                     │
│ • Better user experience                                    │
└────────────────────────────────────────────────────────────┘

Progress Indicators:
┌────────────────────────────────────────────────────────────┐
│ Show status for long operations:                           │
│                                                             │
│ {saving && (                                               │
│   <div className="flex items-center gap-2">                │
│     <div className="animate-spin rounded-full h-4 w-4     │
│                     border-b-2 border-blue-600" />         │
│     <span>Saving changes...</span>                         │
│   </div>                                                    │
│ )}                                                          │
│                                                             │
│ Psychology:                                                 │
│ • User knows something is happening                         │
│ • Reduces anxiety                                          │
│ • Prevents duplicate clicks                                 │
└────────────────────────────────────────────────────────────┘

══════════════════════════════════════════════════════════════
MONITORING & ANALYTICS
══════════════════════════════════════════════════════════════

Performance Metrics to Track:
┌────────────────────────────────────────────────────────────┐
│ Key metrics:                                               │
│ • First Contentful Paint (FCP): < 1.8s                     │
│ • Largest Contentful Paint (LCP): < 2.5s                   │
│ • Time to Interactive (TTI): < 3.8s                        │
│ • First Input Delay (FID): < 100ms                         │
│ • Cumulative Layout Shift (CLS): < 0.1                     │
│                                                             │
│ Page Load Times:                                           │
│ • Dashboard: Target < 2s                                   │
│ • Profile: Target < 1.5s                                   │
│ • Meetings: Target < 2s                                    │
│ • Chat: Target < 1.5s                                      │
│                                                             │
│ API Response Times:                                        │
│ • List queries: < 500ms                                    │
│ • Single get: < 200ms                                      │
│ • Create/Update: < 300ms                                   │
└────────────────────────────────────────────────────────────┘

Error Tracking:
┌────────────────────────────────────────────────────────────┐
│ Monitor for:                                               │
│ • Failed API requests                                       │
│ • JavaScript errors                                         │
│ • Slow queries (> 2s)                                      │
│ • High memory usage                                         │
│ • Excessive re-renders                                      │
│                                                             │
│ Could integrate:                                           │
│ • Sentry for error tracking                                 │
│ • Google Analytics for usage                                │
│ • Custom logging to Base44 platform                         │
└────────────────────────────────────────────────────────────┘
15. Deployment Architecture
┌─────────────────────────────────────────────────────────────┐
│          DEPLOYMENT & INFRASTRUCTURE                         │
└─────────────────────────────────────────────────────────────┘

══════════════════════════════════════════════════════════════
BASE44 PLATFORM ARCHITECTURE
══════════════════════════════════════════════════════════════

Platform Stack:
┌────────────────────────────────────────────────────────────┐
│ ┌──────────────────────────────────────────────────────┐  │
│ │ FRONTEND LAYER (React SPA)                           │  │
│ │ • React 18 application                               │  │
│ │ • Vite build system                                  │  │
│ │ • Tailwind CSS                                       │  │
│ │ • Shadcn/UI components                               │  │
│ └──────────────────────────────────────────────────────┘  │
│              ↓ HTTPS (TLS 1.3)                             │
│ ┌──────────────────────────────────────────────────────┐  │
│ │ CDN LAYER (Cloudflare/AWS CloudFront)                │  │
│ │ • Global edge locations                              │  │
│ │ • Static asset caching                               │  │
│ │ • DDoS protection                                    │  │
│ │ • SSL/TLS termination                                │  │
│ └──────────────────────────────────────────────────────┘  │
│              ↓                                              │
│ ┌──────────────────────────────────────────────────────┐  │
│ │ BASE44 API LAYER (Serverless)                        │  │
│ │ • Entity API endpoints (CRUD)                        │  │
│ │ • Integration endpoints                              │  │
│ │ • Authentication service                             │  │
│ │ • RLS policy enforcement                             │  │
│ └──────────────────────────────────────────────────────┘  │
│              ↓                                              │
│ ┌──────────────────────────────────────────────────────┐  │
│ │ DATABASE LAYER (PostgreSQL/Supabase)                 │  │
│ │ • Entity tables                                      │  │
│ │ • Row-Level Security                                 │  │
│ │ • Automatic backups                                  │  │
│ │ • Point-in-time recovery                             │  │
│ └──────────────────────────────────────────────────────┘  │
│              ↓                                              │
│ ┌──────────────────────────────────────────────────────┐  │
│ │ EXTERNAL SERVICES                                    │  │
│ │ • Google OAuth                                       │  │
│ │ • Email service (SMTP)                               │  │
│ │ • LLM APIs                                           │  │
│ │ • File storage (S3)                                  │  │
│ └──────────────────────────────────────────────────────┘  │
└────────────────────────────────────────────────────────────┘

Serverless Architecture Benefits:
┌────────────────────────────────────────────────────────────┐
│ • Auto-scaling (handles traffic spikes automatically)       │
│ • Pay-per-use pricing (no idle server costs)                │
│ • Zero server management required                           │
│ • Built-in redundancy and failover                          │
│ • Global distribution                                       │
│ • Automatic security patches                                │
└────────────────────────────────────────────────────────────┘

══════════════════════════════════════════════════════════════
DEPLOYMENT PROCESS
══════════════════════════════════════════════════════════════

Development Workflow:
┌────────────────────────────────────────────────────────────┐
│ 1. Developer makes changes in Base44 AI editor             │
│         ↓                                                   │
│ 2. Base44 validates changes                                │
│    • Syntax checking                                       │
│    • Entity schema validation                              │
│    • RLS policy validation                                 │
│         ↓                                                   │
│ 3. Changes saved to project                                │
│         ↓                                                   │
│ 4. Live preview updates automatically                      │
│    • Hot module replacement (HMR)                          │
│    • Instant feedback                                      │
│         ↓                                                   │
│ 5. Developer tests in preview                              │
│         ↓                                                   │
│ 6. Ready to deploy                                         │
│    • Click "Deploy" button                                 │
│    • Or automatic deployment on changes                    │
│         ↓                                                   │
│ 7. Base44 builds production bundle                         │
│    • Optimizes code                                        │
│    • Minifies assets                                       │
│    • Generates SDK                                         │
│         ↓                                                   │
│ 8. Deployment to production                                │
│    • Zero downtime deployment                              │
│    • Automatic rollback if errors                          │
│    • CDN cache invalidation                                │
│         ↓                                                   │
│ 9. Live site updated                                       │
│    • Users see new version on next page load               │
└────────────────────────────────────────────────────────────┘

Zero-Downtime Deployment:
┌────────────────────────────────────────────────────────────┐
│ Blue-Green Deployment Strategy:                            │
│                                                             │
│ ┌─────────┐         ┌─────────┐                           │
│ │ Version │         │ Version │                           │
│ │  1.0    │◄────────│  1.1    │                           │
│ │ (Blue)  │   New   │ (Green) │                           │
│ │ Active  │ Deploy  │ Standby │                           │
│ └─────────┘         └─────────┘                           │
│                           ↓ Health Check                   │
│                     ┌─────────┐                           │
│                     │ Version │                           │
│                     │  1.1    │                           │
│                     │ (Green) │                           │
│           Traffic   │ Active  │                           │
│           Switch ───┤         │                           │
│                     └─────────┘                           │
│                                                             │
│ Process:                                                    │
│ 1. Deploy new version to standby environment               │
│ 2. Run health checks                                       │
│ 3. If healthy, switch traffic to new version               │
│ 4. Monitor for issues                                      │
│ 5. If issues, instant rollback to previous version         │
│ 6. If successful, old version kept as backup               │
└────────────────────────────────────────────────────────────┘

══════════════════════════════════════════════════════════════
ENVIRONMENT MANAGEMENT
══════════════════════════════════════════════════════════════

Environments:
┌────────────────────────────────────────────────────────────┐
│ Development Environment:                                   │
│ • URL: preview.base44.com/app-id                           │
│ • Live preview with hot reload                             │
│ • Test data and test users                                 │
│ • Separate database (development)                          │
│ • All features enabled                                     │
│                                                             │
│ Production Environment:                                    │
│ • URL: Custom domain (e.g., uniconnect.com)                │
│ • Optimized build                                          │
│ • CDN distribution                                         │
│ • Production database                                      │
│ • Real user data                                           │
│ • Monitoring and alerting enabled                          │
└────────────────────────────────────────────────────────────┘

Environment Variables:
┌────────────────────────────────────────────────────────────┐
│ Managed by Base44 Platform:                               │
│ • API_BASE_URL: Backend API endpoint                       │
│ • DATABASE_URL: Database connection string                 │
│ • GOOGLE_OAUTH_CLIENT_ID: OAuth credentials                │
│ • CDN_URL: Asset delivery URL                              │
│                                                             │
│ Automatic injection:                                       │
│ • No .env files needed                                     │
│ • Different values per environment                         │
│ • Encrypted at rest                                        │
└────────────────────────────────────────────────────────────┘

══════════════════════════════════════════════════════════════
SCALABILITY
══════════════════════════════════════════════════════════════

Horizontal Scaling:
┌────────────────────────────────────────────────────────────┐
│ Automatic scaling based on:                                │
│ • Concurrent users                                         │
│ • API request rate                                         │
│ • Database connections                                     │
│                                                             │
│ Example scaling:                                           │
│ • 1-100 users: Single instance                             │
│ • 100-1,000 users: 2-5 instances                           │
│ • 1,000-10,000 users: 5-20 instances                       │
│ • 10,000+ users: 20+ instances                             │
│                                                             │
│ Load Balancing:                                            │
│ • Round-robin distribution                                 │
│ • Health checks every 30s                                  │
│ • Automatic removal of unhealthy instances                 │
│ • Session stickiness for WebSocket connections             │
└────────────────────────────────────────────────────────────┘

Database Scaling:
┌────────────────────────────────────────────────────────────┐
│ Vertical Scaling (Automatic):                              │
│ • CPU and memory increased as needed                       │
│ • Storage auto-expands                                     │
│                                                             │
│ Read Replicas:                                             │
│ • For high read traffic                                    │
│ • Geographic distribution                                  │
│ • Eventual consistency                                     │
│                                                             │
│ Connection Pooling:                                        │
│ • Max 100 connections per instance                         │
│ • Connection timeout: 30s                                  │
│ • Idle timeout: 10 minutes                                 │
└────────────────────────────────────────────────────────────┘

Caching Strategy:
┌────────────────────────────────────────────────────────────┐
│ CDN Caching (Static Assets):                               │
│ • JavaScript bundles: 1 year cache                         │
│ • CSS files: 1 year cache                                  │
│ • Images: 1 month cache                                    │
│ • HTML: No cache (always fresh)                            │
│                                                             │
│ API Response Caching:                                      │
│ • User list: 5 minutes                                     │
│ • Room list: 10 minutes                                    │
│ • Notifications: No cache (real-time)                      │
│ • Meeting requests: No cache (real-time)                   │
│                                                             │
│ Cache Invalidation:                                        │
│ • Automatic on data updates                                │
│ • Manual via admin panel                                   │
│ • Version-based (cache-busting)                            │
└────────────────────────────────────────────────────────────┘

══════════════════════════════════════════════════════════════
MONITORING & OBSERVABILITY
══════════════════════════════════════════════════════════════

System Metrics:
┌────────────────────────────────────────────────────────────┐
│ Automatically monitored:                                   │
│ • CPU utilization                                          │
│ • Memory usage                                             │
│ • Network traffic                                          │
│ • Disk I/O                                                 │
│ • API response times                                       │
│ • Database query performance                               │
│ • Error rates                                              │
│                                                             │
│ Alerting thresholds:                                       │
│ • CPU > 80% for 5 minutes                                  │
│ • Memory > 90% for 2 minutes                               │
│ • Error rate > 5% for 1 minute                             │
│ • API response time > 2s for 5 minutes                     │
│ • Database connections > 80% for 2 minutes                 │
└────────────────────────────────────────────────────────────┘

Application Logs:
┌────────────────────────────────────────────────────────────┐
│ Centralized logging:                                       │
│ • All API requests                                         │
│ • Error stack traces                                       │
│ • User actions (audit log)                                 │
│ • Security events                                          │
│ • Performance metrics                                      │
│                                                             │
│ Log retention:                                             │
│ • Debug logs: 7 days                                       │
│ • Info logs: 30 days                                       │
│ • Error logs: 90 days                                      │
│ • Audit logs: 1 year                                       │
│                                                             │
│ Searchable via:                                            │
│ • Base44 dashboard                                         │
│ • Query by time range                                      │
│ • Filter by level, user, endpoint                          │
└────────────────────────────────────────────────────────────┘

Uptime Monitoring:
┌────────────────────────────────────────────────────────────┐
│ Health checks:                                             │
│ • Every 60 seconds                                         │
│ • From multiple global locations                           │
│ • Test key endpoints:                                      │
│   - Homepage                                               │
│   - API health endpoint                                    │
│   - Database connectivity                                  │
│   - Authentication service                                 │
│                                                             │
│ SLA:                                                        │
│ • Target uptime: 99.9%                                     │
│ • Max downtime: 43 minutes/month                           │
│ • Response time: < 2s (95th percentile)                    │
│                                                             │
│ Incident response:                                         │
│ • Auto-scaling on traffic spikes                           │
│ • Automatic failover to backup                             │
│ • Alert team if manual intervention needed                 │
└────────────────────────────────────────────────────────────┘

══════════════════════════════════════════════════════════════
BACKUP & DISASTER RECOVERY
══════════════════════════════════════════════════════════════

Database Backups:
┌────────────────────────────────────────────────────────────┐
│ Automated backups:                                         │
│ • Full backup: Daily at 2 AM UTC                           │
│ • Incremental backup: Every 6 hours                        │
│ • Transaction logs: Continuous                             │
│                                                             │
│ Retention policy:                                          │
│ • Daily backups: 30 days                                   │
│ • Weekly backups: 90 days                                  │
│ • Monthly backups: 1 year                                  │
│                                                             │
│ Backup locations:                                          │
│ • Primary: Same region as database                         │
│ • Secondary: Different geographic region                   │
│ • Tertiary: Cold storage for long-term retention           │
│                                                             │
│ Point-in-time recovery:                                    │
│ • Restore to any point in last 30 days                     │
│ • Recovery time: < 1 hour                                  │
└────────────────────────────────────────────────────────────┘

Disaster Recovery Plan:
┌────────────────────────────────────────────────────────────┐
│ Scenarios covered:                                         │
│ 1. Region outage                                           │
│    • Automatic failover to backup region                   │
│    • RTO: 15 minutes                                       │
│    • RPO: 5 minutes                                        │
│                                                             │
│ 2. Database corruption                                     │
│    • Restore from most recent backup                       │
│    • RTO: 1 hour                                           │
│    • RPO: 6 hours                                          │
│                                                             │
│ 3. Accidental data deletion                                │
│    • Point-in-time recovery                                │
│    • Can recover specific tables/records                   │
│    • RTO: 30 minutes                                       │
│                                                             │
│ 4. Security breach                                         │
│    • Isolate affected systems                              │
│    • Restore from clean backup                             │
│    • Forced password reset for all users                   │
│    • RTO: 2 hours                                          │
└────────────────────────────────────────────────────────────┘

══════════════════════════════════════════════════════════════
COST ESTIMATION
══════════════════════════════════════════════════════════════

Pricing Model (Approximate):
┌────────────────────────────────────────────────────────────┐
│ Small Event (50 users, 1 week):                            │
│ • Base44 platform: $50/month (includes hosting)            │
│ • Database: $20/month                                      │
│ • Storage: $5/month                                        │
│ • Total: ~$75/month                                        │
│                                                             │
│ Medium Event (500 users, 1 month):                         │
│ • Base44 platform: $150/month                              │
│ • Database: $100/month                                     │
│ • Storage: $20/month                                       │
│ • CDN: $30/month                                           │
│ • Total: ~$300/month                                       │
│                                                             │
│ Large Event (5000 users, 1 week):                          │
│ • Base44 platform: $500/month (prorated)                   │
│ • Database: $400/month                                     │
│ • Storage: $50/month                                       │
│ • CDN: $100/month                                          │
│ • Total: ~$1,050/month                                     │
│                                                             │
│ Note: Actual costs vary based on:                          │
│ • Data transfer volume                                     │
│ • Storage requirements                                     │
│ • API call frequency                                       │
│ • Custom integrations                                      │
└────────────────────────────────────────────────────────────┘
🎉 End of Complete Documentation
This comprehensive documentation covers:

✅ System Architecture - Complete technical stack
✅ Database Schema - All 6 entities with RLS policies
✅ User Flows - Every interaction from registration to meeting completion
✅ Core Functionalities - Profile, meetings, chat, bookings, admin
✅ Edge Cases - 20+ scenarios with solutions
✅ UI/UX Specifications - Complete design system
✅ Security - Authentication, authorization, RLS, GDPR
✅ Performance - Optimization strategies
✅ Deployment - Zero-downtime, auto-scaling, monitoring

Total Pages: 100+ equivalent pages of documentation

This is a production-ready, enterprise-grade platform suitable for international conferences, diplomatic events, and professional networking at scale.